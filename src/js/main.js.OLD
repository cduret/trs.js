/* global Objects */
/* global Tests */
/* global Parser */
/* global datatype */
/* global _match */

var VAR_REGEX = /^[a-zA-Z]\d*?_?$/;

var add_rules = Parser.parse('X 0 + -> 0 . X 1 + -> 0 succ .');

var Term = datatype('Term', { V : { name: String },
                              P : { terms: Array },
                              T:  { name: String, terms: Array } });

// ---------------- PARSE -------------------------------------------

var parse_rules = function(s) {
  var mk_terms = function(ast) {
    var i, result;
    if( ast.expression ) {
      if( VAR_REGEX.exec(ast.expression) !== null ) {
        return Term.V(ast.expression);
      } else {
        return Term.T(ast.expression, []);
      }
    } else if( ast.quotation ) {
      result = [];
      for(i=ast.quotation.length;i--;) {
        result = result.concat(mk_terms(ast.quotation[i]));
      }
      return Term.P(result);
    } else if( ast instanceof Array ) {
      result = [];
      for(i=ast.length;i--;) {
        result = result.concat(mk_terms(ast[i]));
      }
      return result;
    }

    return [];
  };

  var mk_term = function(words) {
    var l = words.length;
    if( words instanceof Array && l > 0 ) {
      var last = words[l-1];
      var exp = last.expression;
      if( exp ) {
        return Term.T(exp, mk_terms(words.slice(0, l-1)));
      }
    }
    return null;
  };

  var _parse_rules = function(ast) {
    if( ast.program ) {
      var i, result = [];
      for(i=ast.program.length;i--;) {
        result = result.concat(_parse_rules(ast.program[i]));
      }
      return result;
    } else if( ast.rule && ast.rule.lhs.length > 0 && ast.rule.rhs.length > 0 ) {
      var lhs = mk_term(ast.rule.lhs);
      if( lhs ) {
        return [[lhs, Term.P(mk_terms(ast.rule.rhs))]];//??
      }
    }
    return [];
  };

  return _parse_rules(Parser.parse(s));
};

var mk_dic = function(rules) {
  var i, result = [];
  for(i=0;i<rules.length;i++) {
    if( _match(rules[i][0], 'T') ) {
      result.push({ name: rules[i][0].name, arity: rules[i][0].terms.length });
    }
  }
  return result;
};

var parse_program = function(dic, s) {
  var arity = function(word) {
    if( word !== undefined ) {
      var i;
      for(i=0;i<dic.length;i++) {
        if( dic[i].name === word ) {
          return dic[i].arity;
        }
      }
    }
    return 0;
  };
  var parse_words = function(stack, words) {
    if( words.length === 0 ) {
      return stack.reverse();
    }

    if( words[0].expression ) {
      var w = words[0].expression;
      var a = arity(w);
      var l = stack.length;
      if( a > 0 ) {
        if( l >= a ) {
          return parse_words(stack.slice(0, l-a).concat(Term.T(w, stack.slice(l-a, l).reverse())), words.slice(1));
        } else {
          console.error('stack underflow for word '+w);
        }
      } else {
        return parse_words(stack.concat(Term.T(w, [])), words.slice(1));
      }
    } else if( words[0].quotation ) {//quotation is a program
      return parse_words(stack.concat(Term.P(parse_words([], words[0].quotation))), words.slice(1));
    }
  };

  var parse_words_rev = function(words) {
    var i, result = [];
    for(i=words.length;i;) {
      if( words[--i].expression ) {
        var w = words[i].expression;
        var a = arity(w);
        result.push(Term.T(w, parse_words_rev(words.slice(i-a, i))));
        i-=a;
      } else if( words[i].quotation ) {
        result.push(Term.P(parse_words_rev(words[i].quotation)));
      }
    }
    return result;
  };

  return Term.P(parse_words([], Parser.parse(s).program));
  //return Term.P(parse_words_rev(Parser.parse(s).program));
};

var render_program = function(program) {
  var _render_program = function(term) {
    var i, out = [];
    if( _match(term, 'P') ) {
      var program = term.terms;
      out.push('[');
      for(i=program.length;i--;) {
        out.push(_render_program(program[i]));
      }
      out.push(']');
    } else if( _match(term, 'V') ) {
      out.push(term.name);
    } else if( _match(term, 'T') ) {
      for(i=term.terms.length;i--;) {
        out.push(_render_program(term.terms[i]));
      }
      out.push(term.name);
    }
    
    return out.join(' ');
  };

  var m = /^\[\s*(.*?)\s*\]$/.exec(_render_program(program));
  return m?m[1]:'';
};


// ---------------- REWRITE -------------------------------------------

var indom = function(x, s) {
  var i;
  for(i=0;i<s.length;i++) {
    if( s[i][0] === x ) {
      return true;
    }
  }
  return false;
};

var app = function(s, x) {
  var i;
  for(i=0;i<s.length;i++) {
    if( s[i][0] === x ) {
      return s[i][1];
    }
  }
};

// subst -> program -> program
var lift = function(s, t) {
  if( _match(t, 'P') ) {
    return Term.P(t.terms.map(function(_t) {
      return lift(s, _t);
    }));
  } else if( _match(t, 'V') ) {
    if( indom(t.name, s) ) {
      return app(s, t.name);
    } else {
      return t;
    }
  } else if( _match(t,'T') ) {
    return Term.T(t.name, lift(s, t.terms));
  }
};

var zip = function(a,b) {
  var i, result = [];
  for(i=0;i<a.length;i++) {
    result.push([a[i], b[i]]);
  }
  return result;
};

var zip_match = function(a_v, a_t) {
  if( a_v.length > a_t.length ) {
    return null;
  }
  var any = function(x) { return _match(x, 'V') && /.*?_$/.exec(x.name); };
  var not_any = function(x) { return _match(x, 'V') && /.*?[^_]$/.exec(x.name); };
  var distribution = function() {
    var nb_any = a_v.filter(any).length;
    var nb_var = a_v.filter(not_any).length;
    var elt_per_any = -1;
    if( nb_any > 0 ) {
      elt_per_any = Math.floor((a_t.length-nb_var)/nb_any);
    }
    return [nb_any, nb_var, elt_per_any];
  };
    
  var i, j = 0, d = distribution(), result = [];
  for(i=0;i<a_v.length;i++) {
    if( any(a_v[i]) ) {
      result.push([a_v[i], a_t.slice(j, j+d[2])]);
      j += d[2];
    } else if( not_any(a_v[i]) ) {
      result.push([a_v[i], a_t[j]]);
      j++;
    }
  }
  return result;
};

// program -> program -> substitution
var match = function(pat, obj) {
  var matchs = function(terms, s) {
    if( terms.length === 0 ) {
      return s;
    }
    var f, g, t, ts, us, x;
    if( _match(terms[0][0], 'P') && _match(terms[0][1], 'P') ) {
      ts = terms[0][0].terms;
      us = terms[0][1].terms;
      return matchs(zip_match(ts, us).concat(terms.slice(1)), s);
    } else if( _match(terms[0][0], 'V') ) {
      x = terms[0][0].name;
      t = terms[0][1];
      if( indom(x, s) ) {
        if( app(s, x).name === t.name ) {
          return matchs(terms.slice(1), s);
        } else {
          throw Error('UNIFY');
        }
      } else {
        return matchs(terms.slice(1), [[x,t]].concat(s));
      }
    } else if( _match(terms[0][1], 'V') ) {
      throw Error('UNIFY');
    } else if( _match(terms[0][0], 'T') && _match(terms[0][1], 'T') ) {
      f = terms[0][0].name;
      ts = terms[0][0].terms;
      g = terms[0][1].name;
      us = terms[0][1].terms;
      if( f === g ) {
        return matchs(zip(ts, us).concat(terms.slice(1)), s);
      } else {
        throw Error('UNIFY');
      }
    }
  };
  return matchs([[pat, obj]], []);
};

// a checker avec P
// les ordres ont pas l'air bons..

// [rule] -> term -> program
var rewrite = function(rules, term) {
  if( rules.length === 0 ) {
    throw Error('NORM');
  }
  var l = rules[0][0];
  var r = rules[0][1];
  try {
    return lift(match(l,term), r);
  } catch(e) {
    if( e.message === 'UNIFY' ) {
      return rewrite(rules.slice(1), term);
    } else { throw e; }
  }
};

var flat_map = function(a, f) {
  var concat_program = function(p1, p2) {
    if( _match(p1, 'P') && _match(p2, 'P') ) {
      return Term.P(p1.terms.concat(p2.terms));
    }
    throw Error('must be two programs to concatenate !');
  };

  return a.map(f).reduce(concat_program, Term.P([]));
};

// program -> program
var norm = function(rules, program) {
  // term -> program
  var _norm = function(term) {
    if( _match(term, 'P') ) {
      //return [flat_map(term, _norm)];
      return term;// do not interpret sub programs !
    } else if( _match(term, 'V') ) {
      return Term.P([term]);
    } else if( _match(term, 'T') ) {
      var u;
      try {
        u = Term.T(term.name, flat_map(term.terms, _norm).terms);
        return norm(rules, rewrite(rules, u));
        //return rewrite(rules, term).terms.map(_norm).reduce(concat_program, Term.P([]));
      } catch(e) {
        if( e.message === 'NORM' ) {
          return Term.P([u]);
          /*if( _match(term, 'T') ) {
            return _norm(Term.T(term.name, term.terms.map(_norm).reduce(concat_program, Term.P([])).terms));
          } else if( _match(term, 'P') ) {
            return term;
          } else {
            return Term.P([term]);
          }*/
        }
        throw e;
      }
    }
  };
  if( _match(program, 'P') ) {
    return flat_map(program.terms,_norm);
  } else {
    throw Error('must be a program to normalize !');
  }
};

var mk_test = function(rules, term) {
  return function() {
    var r = parse_rules(rules);
    return render_program(norm(r, parse_program(mk_dic(r), term)));
  };
};

var mk_tests = function(tests) {
  return tests.map(function(t) {
    return { body: mk_test(t[0], t[1]),
             expected: t[2]
           };
  });
};

Tests.assert_all('rewrite',
  mk_tests([
    ['x 0 + -> x.', '1 0 +', '1'],
    ['x 0 + -> x.', '18 0 + 1 0 +', '18 1'],
    ['x 0 + -> x. x y swap -> y x.', '10 0 swap 0 +', '0 10'],
    ['x 0 + -> x.', '[1 0 +]', '[ 1 0 + ]'],
    ['x0 0 + -> x0.', '[1 0 +]', '[ 1 0 + ]'],
    ['x 0 + -> x.', '[1 0 + 7]', '[ 1 0 + 7 ]'],
    ['x 0 + -> x.', '[1 0 +] 7', '[ 1 0 + ] 7'],
    ['x 0 + -> x.', '[[1 0 +]]', '[ [ 1 0 + ] ]'],
    ['x 0 + -> x.', '[[1 0 +] 7]', '[ [ 1 0 + ] 7 ]'],
    ['x 0 + -> x.', '[[1 0 +] 0 +]', '[ [ 1 0 + ] 0 + ]'],
    ['x 0 + -> x.', '[[1 0 +] x +]', '[ [ 1 0 + ] x + ]'],
    ['x 0 + -> x. x 1 * -> x.', '[[1 0 +] 1 *]', '[ [ 1 0 + ] 1 * ]']
  ])
);
